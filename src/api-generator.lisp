(in-package #:cl-neovim)


(defvar *here* #.(or *compile-file-pathname* *load-pathname* *default-pathname-defaults*))
(defvar *generated-api-file* (merge-pathnames "generated-api" *here*))
(defparameter *manual-implementation* '(subscribe unsubscribe call-atomic buffer-number))
(defparameter *arg-conversions*
  '(("boolean" . (or arg :false))
    ("array"   . (or arg #()))))

(cl:defun setterp (name)
  "Is name a setter?"
  (and (member "set" (split-sequence #\_ name) :test #'string=) T))

(cl:defun predicatep (name)
  "Is name a predicate?"
  (and (member "is" (split-sequence #\_ name) :test #'string=) T))

(cl:defun clean-up-name (name &optional
                              (modifiers '("vim" "nvim" "get" "set" "is" "list"))
                              (replacements '(("buf" "buffer") ("win" "window") ("bufs" "buffers") ("wins" "windows"))))
  "Removes all substrings specified in modifiers from name and applies all
   replacements."
  (let ((components (split-sequence #\_ name)))
    (setf components (remove-if #'(lambda (c) (member c modifiers :test #'string=)) components))
    (loop for (old new) in replacements
          do (setf components (substitute new old components :test #'string=)))
    (if (predicatep name)
      (setf components (append components '("p"))))
    (format nil "~{~A~^_~}" components)))

(cl:defun parse-parameters (parameters)
  "Extract names from nvim api's metadata of arguments into a list of symbols."
  (mapcar #'(lambda (arg) (vim-name->symbol (second arg))) parameters))

(cl:defun mdata->lisp-function (&key name parameters &allow-other-keys)
  "Create functions from the parsed nvim api (generated by api.lisp)."
  (let* ((parameter-names (append (parse-parameters parameters)))
         (instance-parameter '(&optional (instance *nvim-instance*)))
         (fn-name (vim-name->symbol (clean-up-name name)))
         (async-fn-name (symbol-concat fn-name '/a))
         (funcalls `((,fn-name call/s)
                     (,async-fn-name call/a)))
         (arg-conversions (loop for (type _) in parameters
                                for name in parameter-names
                                when (assoc type *arg-conversions* :test #'string-equal)
                                  collect `(,name ,(subst name 'arg (rest (assoc type *arg-conversions* :test #'string-equal)) :test #'symbol-name=)))))
    (loop for (fn-name fn) in funcalls
          collect (if (setterp name)
                    `(cl:defun (setf ,fn-name) (,@(last parameter-names) ,@(butlast parameter-names) ,@instance-parameter)
                       ,(if arg-conversions
                          `(let (,@arg-conversions)
                             (,fn instance ,name ,@parameter-names))
                          `(,fn instance ,name ,@parameter-names)))
                    `(cl:defun ,fn-name (,@parameter-names ,@instance-parameter)
                       ,(if arg-conversions
                          `(let (,@arg-conversions)
                             (,fn instance ,name ,@parameter-names))
                          `(,fn instance ,name ,@parameter-names)))))))

(cl:defun function-metadata (f)
  (loop for k being the hash-keys in f using (hash-value v)
        append (list (alexandria:make-keyword (vim-name->symbol k)) v)))

(cl:defun parse-api (api)
  (let ((functions (gethash "functions" api)))
    (loop for f in functions
          collect (function-metadata f))))

(cl:defun retrieve-api ()
  (second (call/s t "vim_get_api_info")))

(cl:defun remove-shadowing-definitions (parsed-api)
  (let* ((sorted-api (sort parsed-api #'> :key #'(lambda (md) (getf md :since))))
         (fn-names (mapcar #'(lambda (md) (vim-name->symbol (clean-up-name (getf md :name)))) sorted-api))
         (settersp (mapcar #'(lambda (md) (setterp (getf md :name))) sorted-api)))
    (let* ((removed-manual-api (remove-if #'(lambda (fn-name)
                                              (find fn-name *manual-implementation*))
                                          (zip sorted-api fn-names settersp) :key #'second))
           (removed-duplicates (remove-duplicates removed-manual-api :key #'rest :test #'equal :from-end T)))
      (mapcar #'first removed-duplicates))))


(cl:defun generate-api (&optional (filename *generated-api-file*))
  (let* ((api (remove-shadowing-definitions (parse-api (retrieve-api))))
         (exports (mapcar #'(lambda (md) (vim-name->symbol (clean-up-name (getf md :name)))) api))
         (permission-to-write (y-or-n-p (format NIL "Writing generated API into ~A. Continue?" filename))))
    (when permission-to-write
      (with-open-file (out filename :direction :output :if-exists :supersede :if-does-not-exist :create)
        (format out ";;; File automatically generated by (nvim::generate-api)~%")
        (format out "(in-package :cl-neovim)~%~%~%")
        (loop for metadata in api
              do (format out "~{~S~%~%~}~%" (apply #'mdata->lisp-function metadata)))
        (format out "(:export ~{~(#:~A~)~^ ~})~%" (remove-duplicates exports))
        (format out "(:export ~{~(#:~A~)~^ ~})~%" (mapcar #'(lambda (sym) (symbol-concat sym '/a)) (remove-duplicates exports)))))))
