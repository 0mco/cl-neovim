(in-package #:cl-neovim)


(cl:defun parse-parameters (parameters)
  "Extract names from nvim api's metadata of arguments into a list of symbols."
  (cond ((listp parameters) (mapcar #'(lambda (arg) (vim-name->symbol (second arg))) parameters))
        ((stringp parameters) (list (vim-name->symbol parameters)))
        (t NIL)))

(defmacro mdata->lisp-function (&key name parameters &allow-other-keys)
  "Create functions from the parsed nvim api (generated by api.lisp)."
  (let* ((parameter-names (append (parse-parameters parameters)))
         (instance-parameter '(&optional (instance *nvim-instance*)))
         (fn-name (vim-name->symbol (clean-up-name name)))
         (sync-fn-name (symbol-concat fn-name '/s))
         (async-fn-name (symbol-concat fn-name '/a))
         (funcalls `((,fn-name #'call/s)
                     (,sync-fn-name #'call/s)
                     (,async-fn-name #'call/a)))
         (false-conversions (loop for (type _) in parameters
                                  for name in parameter-names
                                  when (string-equal type "boolean")
                                    collect `(,name (or ,name :false)))))
    `(progn
       ,@(loop for (fn-name fn) in funcalls
               collect (if (setterp name)
                         `(cl:defun (setf ,fn-name) (,@(last parameter-names) ,@(butlast parameter-names) ,@instance-parameter)
                            (let (,@false-conversions)
                              (funcall ,fn instance ,name ,@parameter-names)))
                         `(cl:defun ,fn-name (,@parameter-names ,@instance-parameter)
                            (let (,@false-conversions)
                              (funcall ,fn instance ,name ,@parameter-names))))))))
